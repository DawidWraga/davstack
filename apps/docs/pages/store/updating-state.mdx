import { Callout } from 'nextra/components';

# Updating State

Davstack Store provides two main methods for updating state: `set` and `assign`. Both methods use Immer under the hood, allowing you to update state immutably.

## Example

```tsx
import { store } from '@davstack/store';

const userStore = store()
	.state({
		name: 'John',
		age: 25,
		address: {
			street: '123 Main St',
			city: 'Anytown',
		},
	})
	.actions((store) => ({
		happyBirthday() {
			store.age.set(store.age.get() + 1);
		},
	}));

function AddressForm() {
	const userAddress = userStore.address.use();

	return (
		<form>
			<input
				value={userAddress.street}
				onChange={(e) => userStore.address.street.set(e.target.value)}
			/>
			<input
				value={userAddress.city}
				onChange={(e) => userStore.address.city.set(e.target.value)}
			/>
		</form>
	);
}
```

## Best Practices

- It's generally recommended to enapsulate state updates in actions, and avoid directly mutating state properties outside of actions. This helps to keep your codebase clean and maintainable.
- Use the `set` method to update a single state property, and `assign` to update multiple properties at once.

## The `set` Method

Use `set` to update the value of a state property.

```tsx
import { store } from '@davstack/store';

const countStore = store(0);

countStore.set(5);
```

The set method can also be used to update nested state properties:

```tsx
const userStore = store({
	name: 'John',
	age: 25,
	address: {
		street: '123 Main St',
		city: 'Anytown',
	},
});

userStore.address.city.set('Newtown');
```

## The `assign` Method

The `assign` method is similar to `set` but is specifically designed for updating multiple properties of an object at once. It uses `Object.assign` under the hood.

```tsx
const userStore = store({
	name: 'John',
	age: 25,
	address: {
		street: '123 Main St',
		city: 'Anytown',
	},
});

userStore.assign({
	name: 'Jane',
	age: 30,
});
```

<Callout type="info" emoji="ℹ️">
	When using `assign`, only the specified properties will be updated. Other
	properties will remain unchanged.
</Callout>

### Updating Nested State with `assign`

You can also use `assign` to update multiple nested state properties:

```tsx
userStore.address.assign({
	street: '456 Elm St',
	city: 'Newtown',
});
```

Note: the `assign` method only exists on object data type

## Using set with Callbacks

When passing a callback to to the `set` function, the type of callback you need to pass depends on the state datatype.

The types fully reflect which type of callback is required and therefore your IDE guide you.

### using `set(draft=>{})` with objects/arrays

Calling `.set` on an object/array uses immer under the hook, allowing you to mutate a draft copy of the state while maininaining immutability.

```tsx
const userStore = store({ name: 'John', age: 20 });

// settings objects uses immer
userStore.set((draft) => {
	draft.name = 'Jane';
	draft.age = 30;
});

//
const todosStore = store([
	{ id: 1, text: 'write docs' },
	{ id: 2, text: 'sleep' },
]);

todosStore.set((draft) => {
	draft.push('another task');
});

todosStore.set(draft=>{
	cosnt firstTodo = todosStore[0];
	firstTodo.text = "new text"
})
```

### Using `set(preValue=>...) with primatives

Calling `set` on other data types behaves slightly differently.
You are given the previous value of the property and you must return the new value from the callback.

```tsx
userStore.age.set((prevAge) => prevAge + 1);
```

### Key differences between using set callback

- objects/arrays:

  - you can directly modify the draft and you dont need to return anything

- primative values:

  - gets the previous value of the property, you must return the new value from the callback

## Additional notes:

- calling `.set(value)` on arrays/object behaves the same as other values. The difference only arises when passing a callback to the `set` function.

- Since `@davstack/store 1.3.0` root level array stores are fully supported

- You no longer need to consider the limitations of immer as non-draftable values eg MediaRecorder or window will default to regular zustand setters.
