Here's the updated API design document based on the new version of the store:

# API Design

## Creating a Store

Types are inferred from the initial state object.

```tsx
const counterStore = createStore({ count: 0 });
```

## Subscribing to State Changes and Updating State

```tsx
const Counter = () => {
	const count = counterStore.count.use();
	return (
		<div>
			<p>Count: {count}</p>
			<button
				onClick={() => counterStore.count.set(counterStore.count.get() + 1)}
			>
				Increment
			</button>
		</div>
	);
};
```

## Accessing State Outside Components

Useful for accessing state in callbacks or conditionals.

```tsx
const handleSubmit = async () => {
	const count = counterStore.count.get();
	// ...
};
```

## Local State

```tsx
const counterStore = createStore({ count: 0 });

const Counter = () => {
	const localCounterStore = counterStore.useLocalStore();
	const count = localCounterStore.count.use();
	return (
		<div>
			<p>Count: {count}</p>
			<button
				onClick={() =>
					localCounterStore.count.set(localCounterStore.count.get() + 1)
				}
			>
				Increment
			</button>
		</div>
	);
};

const MultipleCountersWithDifferentValues = () => {
	return (
		<>
			<counterStore.LocalProvider initialValue={{ count: 1 }}>
				<Counter />
			</counterStore.LocalProvider>
			<counterStore.LocalProvider initialValue={{ count: 5 }}>
				<Counter />
			</counterStore.LocalProvider>
		</>
	);
};
```

## Defining Actions and Computed Properties

```tsx
const counterStore = createStore({ count: 0 }).extend((store) => ({
	getDoubled() {
		return store.count.get() * 2;
	},
	increment() {
		store.count.set(store.count.get() + 1);
	},
	decrement() {
		store.count.set(store.count.get() - 1);
	},
}));

const Counter = () => {
	const count = counterStore.count.use();
	const doubled = counterStore.getDoubled();
	return (
		<div>
			<p>Count: {count}</p>
			<p>Doubled: {doubled}</p>
			<button onClick={counterStore.increment}>Increment</button>
			<button onClick={counterStore.decrement}>Decrement</button>
		</div>
	);
};
```

## Accessing and Updating the Entire State

```tsx
const counterStore = createStore({ count: 0 });

const counterState = counterStore.use();
const counterValues = counterStore.get();

counterStore.set({ count: 10 });
counterStore.set((state) => {
	state.count = 10;
});

counterStore.assign({ count: 10 });
```

## Performance Optimizations

The `useTracked` method from `react-tracked` can be used for performance optimizations by minimizing unnecessary re-renders. This uses proxies under the hood to track which properties are accessed.

```tsx
const Counter = () => {
	// only rerenders when properties accessed using dot notation have changed
	const state = counterStore.useTracked();
	// only rerenders when count has changed
	const count = counterStore.count.useTracked();
	// ...
};
```

## Options

The `createStore` function accepts an optional second parameter for options.

```tsx
const counterStore = createStore(
	{ count: 0 },
	{
		middlewares: [],
		devtools: true,
		persist: true,
		immer: true,
		name: 'counterStore',
	}
);
```

- `middlewares`: an array of middleware functions
- `devtools`: a boolean to enable/disable devtools integration
- `persist`: a boolean to enable/disable state persistence
- `immer`: a boolean to enable/disable immer integration
- `name`: a string to name the store, used for devtools

The main changes in the updated API design are:

- The `useLocalStore` method is used to access the local store instead of `useLocal`.
- The `LocalProvider` component is used to provide the local store to child components instead of `Provider`.
- The `set` method now takes a value or a function that returns a value, instead of a function that mutates the draft state.
- The `assign` method is used to merge state instead of `set` with an object.

These changes reflect the updated implementation of the store and provide a more consistent and intuitive API for developers using the library.
