# DavStack Store

The most intuitive and pratical React state management library, built on top of [Zustand](https://github.com/pmndrs/zustand).

Zustand is a small, fast and scalable state-management solution battle-tested against common pitfalls, like the dreaded [zombie child problem](https://react-redux.js.org/api/hooks#stale-props-and-zombie-children), [react concurrency](https://github.com/bvaughn/rfcs/blob/useMutableSource/text/0000-use-mutable-source.md), and [context loss](https://github.com/facebook/react/issues/13332) between mixed renderers.

## Key Features and benefits over Zustand

1. **Simple API**: Just define the initial state, getters/setters/hooks/types are automatically generated. No need to write boilerplate code.
2. **Computed Properties and Actions**: Define derived state and actions that automatically update when dependent state changes.
3. **Local State Management**: Scope state to a subtree of components using the `LocalProvider` component.

## Installation

```bash
npm install zustand @davstack/store
```

## Subscribing to State Changes and Updating State

```tsx
import { createStore } from '@davstack/store';

const counterStore = createStore({ count: 0 });

const Counter = () => {
	const count = counterStore.count.use();

	return (
		<div>
			<p>Count: {count}</p>
			<button onClick={() => counterStore.count.set(count + 1)}>
				Increment
			</button>
			<button onClick={() => counterStore.count.set(count - 1)}>
				Decrement
			</button>
		</div>
	);
};
```

# Basic Usage

Create a store with an initial state, and the types will be inferred automatically

```tsx
import { createStore } from '@davstack/store';
const userStore = createStore({
	name: 'John Doe',
});
```

Subscribe to state changes inside React components using the autogenerated `use` hook

```tsx
const name = userStore.name.use();
```

Update state using the autogenerated `set` method

```tsx
userStore.name.set('Jane Doe');
```

Get the current state value using the autogenerated `get` method, eg outside of a component or inside a callback

```tsx
const name = userStore.name.get();
```

### Defining Actions and Computed Properties

Use the `extend` method to define actions and computed properties:

```tsx
const counterStore = createStore({ count: 0 }).extend((store) => ({
	increment() {
		store.count.set(store.count.get() + 1);
	},
	decrement() {
		store.count.set(store.count.get() - 1);
	},
	useDoubled() {
		return store.count.use() * 2;
	},
}));

const Counter = () => {
	const count = counterStore.count.use();
	const doubled = counterStore.useDoubled();

	return (
		<div>
			<p>Count: {count}</p>
			<p>Doubled: {doubled}</p>
			<button onClick={counterStore.increment}>Increment</button>
			<button onClick={counterStore.decrement}>Decrement</button>
		</div>
	);
};
```

### Usage without selectors

Every key inside the store initial value automatically gets a `use`, `set`, and `get` method. You can use them directly without defining selectors.

This ensures that if `count` is changed, the component will re-render, while `secondCount` changes will not trigger a re-render.

However, you can also access the same methods on the store itself:

```tsx
const counterStore = createStore({
	count: 0,
	secondCount: 0,
});

// selector usage
const count = counterStore.count.use();
const currentCount = counterStore.count.get();
counterStore.count.set(10);

// usage without selectors:
const countAndSecondCount = counterStore.get();
// { count: 0, secondCount: 0 }
counterStore.set((state) => {
	// Uses immer under the hood to update state immutably
	state.count = 10;
});
counterStore.assign({ count: 10, secondCount: 20 });
```

### Local State Management

Use the `LocalProvider` component to scope state to a subtree of components:

```tsx
import React from 'react';
import { counterStore } from './store';

const ParentComponent = () => {
	return (
		<counterStore.LocalProvider initialValue={{ count: 5 }}>
			<ChildComponent />
		</counterStore.LocalProvider>
	);
};

const ChildComponent = () => {
	const localStore = counterStore.useLocalStore();
	const count = localStore.count.use();

	return <div>Count: {count}</div>;
};
```

## Caveats

- The library is designed to work with React and may not be suitable for other frameworks or non-React environments.
- Be mindful of the order in which you call the store methods. `createStore` should always be called first, followed by `extend` and other methods.

For more detailed examples and advanced usage, please refer to the [documentation](link-to-documentation) and [examples](link-to-examples).

## Contributing

Contributions are welcome! Please read our [contributing guide](link-to-contributing-guide) for details on our code of conduct and the submission process.

## License

This project is licensed under the [MIT License](link-to-license). See the LICENSE file for details.
